# 데이터베이스

데이터베이스는 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음. 
해당 데이터베이스를 제어, 관리하는 통합 시스템을 DBMS 라고 하며
데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 수정, 삭제, 조회 등을 수행할 수 있고
실시간 접근과 동시 공유가 가능하다.

![image](https://github.com/user-attachments/assets/c139efd4-2c27-42c0-b49a-4636e7ee6c01)

앞 그림처럼 데이터베이스 위에 DBMS가 있고 그 위에 응용 프로그램이 있으며 이러한 구조를 기반으로 데이터를 주고 받는다
예를 들어 MySQL 이라는 DBMS가 있고 그 위에 응용 프로그램에 속하는 Node.js 나 php 에서 해당 데이터베이스 안에 있는 데이터를 끄집어내
해당 데이터 관련 로직을 구축할 수 있는 것

## 엔티티
엔티티는 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미.
예를 들어 회원이라는 엔터티가 있다 해보면 회원은 이름, 아이디, 주소, 전화번호의 속성을 가질 것.
물론 이보다 많은 속성이 있지만 서비스의 요구 사항에 맞춰 속성이 정해진다.
예를 들어 주소라는 속성이 서비스의 요구 사항과 무관한 속성이라면 주소라는 속성은 사라지게 된다.

### 약한 엔티티와 강한 엔티티
엔티티는 약한 엔티티와 강한 엔티티로 나뉜다.
예를 들어 A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔터티고 B는 강한 엔터티가 된다.
예를 들어 방은 건물 안에만 존재하기 때문에 방은 약한 엔터티라 할 수 있고 건물은 강한 엔터티라고 할 수 있다.

## 릴레이션
릴레이션은 데이터베이스에서 정보를 구분하여 저장하는 기본 단위다. 엔터티에 관해 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리한다.
앞의 그림처럼 회원이라는 엔터티가 데이터베이스에서 관리될 대 릴레이션으로 변화된 걸 볼 수 있다.
릴레이션은 관계형 데이터베이스에서는 테이블이라 하며 NoSQL 에서는 컬렉션이라 한다.

### 테이블과 컬렉션
데이터베이스의 종류는 크게 관계형 데이터베이스와 NoSQL 데이터베이스로 나눌 수 있다.
이 중 대표적인 관계형 데이터베이스인 MySQL 과 대표적인 NoSQL 데이터베이스인 MongoDB 데이터베이스의 구조는 도큐먼트-컬렉션-데이터베이스로 이뤄져있다.
레코드가 쌓여 테이블이 되고 테이블이 쌓여 데이터베이스가 되는 것.

## 속성
속성은 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보.
예를 들어 차라는 엔터티의 속성을 뽑으면 차 넘버, 바퀴 수, 차 색깔, 차종 등이 있을 것.
이 중에서 서비스의 요구사항을 기반으로 관리해야할 필요가 있는 속성들만 엔터티의 속성이 된다.

## 도메인
도메인은 릴레이션에 포함된 각 속성들이 가질 수 있는 값의 집합.
예를 들어 성별이라는 속성이 있으면 이 소ㅗㄱ성이 가질 수 있는 값은 남,여 라는 집합이 된다.

![image](https://github.com/user-attachments/assets/a6e8c0ed-0d34-4bbc-aae0-dbcb54784608)

### 필드와 레코드
앞에서 설명한 걸 기반으로 데이터베이스에서 필드와 레코드로 구성한 테이블을 만들 수 있다.
회원이라는 엔터티는 member 라는 테이블로 속성인 이름, 아이디 등을 갖고 있으면 name, ID, address 등의 필드를 갖는다.
그리고 이 테이블에 쌓이는 행 단위의 데이터를 레코드 도는 튜플이라 한다.

예를 들어 책이라는 엔터티를 정의하고 이를 기반으로 테이블을 만들어 볼 것.
먼저 책의 제목, 책의 가격, 책의 ISBN, 책의 저자, 책의 출판년도 등이 있을 것.
일단 수많은 속성 중에 이름, 저자의 아이디, 출판년도, 장르, 생성일시, 업데이트 일시만 있다 해보자

이 엔터티를 데이터베이스에 넣어 테이블로 만들려면 어떻게 해야할까
이 속성에 맞는 타입을 정의해야 한다. 참고로 MongoDB와 MySQL등 데이터베이스마다 조금씩 차이가 있는데 MySQL 을 기준으로 설명할 것.
- 책의 아이디 : INT
- 책의 제목 : VARCHAR (255)
- 책의 저자 아이디 : INT
- 책의 출판년도 : VARCHAR (255)
- 책의 장르 : VARCHAR (255)
- 생성 일시 : DATETIME
- 업데이트 일시 : DATETIME

이를 MySQL 테이블로 구현하려면 다음과 같은 코드를 입력하면 된다

```mysql
CREATE TABLE book(
    id INT NOT NULL AUTO_INCREMENT,
    title VARCHAR(255),
    author_id INT,
    publishing_year VARCHAR(255),
    genre VARCHAR(255),
    created_at DATETIME,
    updated_at DATETIME,
    PRIMARY KEY (id)
);
```
### 필드 타입
필드는 타입을 갖는다. 예를 들어 이름이 문자열, 전화번호는 숫자일텐데 이러한 타입들은 DBMS 마다 다르며 이 책에서는 MySQL 을 기준으로 설명할 것.
여러 가지 타입이 있고 대표적인 타입인 숫자, 날짜, 문자 타입에 대해 알아볼 것.

#### 숫자타입
숫자 타입으로는 TINYINT, SMALLINT, MEDIUM INT, INT, BIGINT 등이 있다.

![image](https://github.com/user-attachments/assets/e1cd1b41-f1fe-470a-941c-078144d61a31)

| 타입       | 용량 (바이트) | 최솟값 (부호 있음) | 최솟값 (부호 없음) | 최댓값 (부호 없음) | 최댓값 (부호 있음)    |
|----------| ---------- | ------------- | -------------- | -------------- |----------------|
| TINYINT  | 1 | -128 | 0 | 127 | 255 |
| SMALLINT | 2 | -32768 | 0 | 32767 | 65535 |
| MEDIUMINT | 3 | -8388608 | 0 | 8388607 | 16777215 |
|INT | 4 | -2147483648 | 0 | 2147483647 | 4294967295 |
| BIGINT | 8 | -263 | 0 | 263-1 | 264-1 |

#### 날짜 타입
날짜타입으로는 DATE, DATETIME, TIMESTAMP 등이 있다

- **DATE** : 날짜 부분은 있지만 시간 부분은 없는 값에 사용. 지원되는 범위는 100-01-01 ~ 9999-12-31이고 3바이트의 용량을 갖는다
- **DATETIME** : 날짜 및 시간 부분을 모두 포함하는 값에 사용된다. 지원되는 범위는 1000-01-01 00:00:00 에서 9999-12-31 23:59:59 이다. 8 바이트의 용량을 갖는다
- **TIMESTAMP** : 날짜 및 시간 부분을 모두 포함하는 값에 사용된다. 1970-01-01 00:00:01 에서 2038-01-19 03:14:07까지 지원하며 4바이트의 욕량을 갖는다.

#### 문자 타입
문자타입으로는 CHAR, VARCHAR, TEXT, BLOB, ENUM, SET 이 있다.

- **CHAR 와 VARCHAR** :
CHAR 또는 VARCHAR 모두 그 안에 수를 입력해 몇 자까지 입력할지 정한다. 예를 들어 CHAR(30) 이라면 최대 30글자까지 입력할 수 있다.
CHAR는 고정 길이 문자열이며 길이는 0-255 사이의 값을 갖는다. 레코드를 저장할 때 무조건 선언한 길이 값으로 고정해 저장된다. 예를 들어 CHAR(100) 으로 선언한 후 10글자를 저장해도 100바이트로 저장되게 된다.
<BR> VARCHAR 는 가변 길이 문자열이다. 길이는 0-65535 사이의 값으로 지정할 수 있으며 입력된 데이터에 따라 용량을 가변시켜 저장한다.
예를 들어 VARCHAR (10000) 으로 선언했음에도 10글자의 이메일을 저장할 경우 10글자에 해당하는 바이트 + 길이기록용 1바이트로 저장하게 된다
그렇기 때문에 CHAR의 경우 유동적이지 않은 길이를 가진 데이터의 경우에 효율적이며 유동적인 길이를 갖는 데이터는 VARCHAR에 저장하는게 좋다.

- **TEXT 와 BLOB** :
두 개의 타입 모두 큰 데이터를 저장할 대 쓰는 타입이다.
  - **TEXT** 는 큰 문자열 저장에 쓰며 주로 게시판의 본문을 저장할 때 사용
  - **BLOB** 은 이미지, 동영상 등 큰 데이터 저장에 쓴다. 그러나 보통은 아마존의 이미지 호스팅 서비스인 S3를 이용하는 등 서버에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장한다.

- **ENUM 과 SET** :
ENUM과 SET 모두 문자열을 열거한 타입.
  - **ENUM**은 ENUM('x-small', 'small', 'medium', 'large', 'x-large') 형태로 쓰이며 이 중에서 하나만 선택하는 단일 선택만 가능하고
    ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입된다. ENUM을 이용하면 x-samll 등이 0, 1 등으로 매핑되어 메모리를 적게 사용하는 이점을 얻는다.
    ENUM은 최대 65535 개의 요소들을 넣을 수 있다.
  - **SET** 은 ENUM과 비슷하지만 여러개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다는 점이 다르다

참고로 ENUM이나 SET을 쓸 경우 공간적 이점을 볼 수 있지만 애플리케이션 수정에 따라 데이터베이스 ENUM 이나 SET 에서 정의한 목록을 수정해야 한다는 단점이 있다.

## 관계
데이터베이스에 테이블은 하나만 있는게 아니다. 여러 개의 테이블이 있고 이런 테이블으 서로의 관계가 정의되어 있다.
이런 관계를 관계화살표로 나타낸다.

![image](https://github.com/user-attachments/assets/ed91ee1e-102b-42fd-beda-34f3aa614f0a)

### 1:1 관계

예를 들어 유저당 유저 이메일이 한 개 있다면, 이 경우느 1:1 관계가 된다

![image](https://github.com/user-attachments/assets/754af2ef-d71a-4d79-b61b-8c1f602e9c9b)

1:1 관계는 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어 준다.

### 1:N 관계

예를 들어 쇼핑몰을 운영한다 해보자. 한 유저 당 여러 개의 상품을 장바구니에 넣을 수 있을 것. 이 경우 1:N 관계가 된다.
물론 하나도 넣지 않는 0개의 경우도 있으니 0도 포함되는 화살표를 통해 표현해야 한다.

![image](https://github.com/user-attachments/assets/99c50e40-ffda-47be-94fd-622d63b4880a)

이렇게 한 개체가 많은 개체를 포함하는 관계를 말한다.

### N:M 관계
학생과 강의의 관계를 정의하면, 학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생을 포함할 수 있다. 이 경우가 N:M 이 된다.

![image](https://github.com/user-attachments/assets/09930b25-0794-4bf2-9904-8e406cf38c32)

중간에 학생_강의라는 테이블이 끼어있는 걸 볼 수 있다.
N:M은 테이블 두 개를 직접적으로 연결해 구축하지 않고 1:N, 1:M 이라는 관계를 갖는 테이블 두 개로 나눠 설정.

## 키

테이블 간의 관계를 좀 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치로 
기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다.

![image](https://github.com/user-attachments/assets/e70ddc3f-b251-4a2e-99df-9cfc7ee764b3)

키들은 앞의 그림과 같은 관계를 갖는다.
슈퍼키는 유일성이 있고 그 안에 포함된 후보키는 최소성까지 갖춘 키다.
후보키 중에서 기본키로 선택되지 못한 키는 대체키가 된다.
유일성은 중복되는 값은 없으며 최소성은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것을 말한다.

### 기본키
기본키는 줄여서 PK 또는 프라이머리키라 부르며, 유일성과 최소성을 만족하는 키.
테이블의 데이터 중 고유하게 존재하는 속성이며 기본키에 해당하는 데이터는 중복되어선 안된다.
복합키를 기본키로 사용한다면 최소성을 만족하지 않기 때문에 기본키는 자연키나 인조키 중에 골라 설정한다.

#### 자연키

예를 들어 유저 테이블을 만든다 가정하면 주민등록번호, 이름, 성별 등의 속성이 있다.
이 중 이름, 성별 등은 중복된 값이 들어올 수 있으므로 부적절하고 남는 것은 주민등록번호다.
이런 식으로 중복된 값들을 제외해 중복되지 않는 걸 자연스레 뽑아 나온 키를 자연키라 한다.
자연키는 언젠가 변하는 속성을 갖는다.

#### 인조키

예를 들어 유저 테이블을 만든다 했을 때 회원 테이블을 생성한다 가정하면
주민등록번호, 이름, 성별 등의 속성이 있다. 여기에 인위적으로 유저 아이디를 부여한다.
이를 통해 고유 식별자가 생긴다. 오라클은 sequence, MySQL은 auto increment 등으로 설정.
이렇게 인위적으로 생성한 키는 인조키로 자연키와 대조적으로 변하지 않는다. 따라서 보통 기본키는 인조키로 설정.

### 외래키

외래키는 FK라고도 하며 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용.

![image](https://github.com/user-attachments/assets/807c0d4f-46fe-4de7-967a-4d7f1cf81676)

외래키는 중복되어도 괜찮다. 

### 후보키
후보키는 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키이다.

### 대체키
대체키는 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말한다.

### 슈퍼키
슈퍼키는 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키.