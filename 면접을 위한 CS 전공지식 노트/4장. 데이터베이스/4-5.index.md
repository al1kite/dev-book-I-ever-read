# 인덱스

## 인덱스의 필요성
인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다.
예를 들어 책 마지막 장의 찾아보기라 생각하면 된다.
책의 본문이 있고 그 본문 안에 내가 찾고자 하는 항목을 찾아보기를 통해 빠르게 찾을 수 있다.
이와 마찬가지로 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있다.

### B-트리
인덱스는 보통 B-트리라는 자료구조로 이루어져 있다. 이는 루트 노드, 리프 노드,
그리고 루트 노드와 리프 노드 사이에 있는 브랜치 노드로 나뉜다.
먼저 루트 노드와 리프 노드를 기반으로 설명하면 다음과 같다.

![image](https://github.com/user-attachments/assets/c408f30d-b58a-4da6-be28-a8368bfcd918)
![image](https://github.com/user-attachments/assets/f2b808b4-02a1-4764-a257-6ba1ec2c4b5f)
예를 들어 E를 찾는다고 하면 전체 테이블을 탐색하는게 아니라 E가 있을 법한 리프노드로 들어가서 E를 탐색하면 쉽게 찾을 수 있다.

사진 속에는 P라는 루트 노드를 가지고 있다. MySQL에서 데이터를 검색할 때 인덱스의 루트 노드부터 시작한다. 즉, 루트 노드는 데이터베이스 테이블에서 첫 번째 진입점이다.
B-트리는 각 노드가 다수의 키(데이터)를 가질 수 있으며, 이 키는 정렬되어 있다.

P 노드 밑에 내부 노드로 C, G, M과 같은 노드들이 있다. 이들은 부모 노드에서 특정 범위의 데이터를 나타내고 있으며, 자식 노드를 탐색하는 기준이 된다.
B-트리는 이러한 방식으로 여러 계층을 만들어 효율적으로 데이터를 분류한다.
루트에서부터 자식 노드로 내려가면서 찾고자 하는 데이터가 어느 범위에 속하는지 확인한다.

B-트리 인덱스에서 검색은 루트에서 시작해 각 노드의 키 값들과 비교하면서 적절한 자식 노드로 이동한다.
예를 들어, P 노드에서 키를 비교해 찾고자 하는 값이 C와 G 사이에 있다면, C 노드로 이동하여 추가적인 탐색을 진행하는 것.

잎 노드는 더 이상 자식이 없는 노드를 의미하며, 이미지는 A, B, E, F, J, K 등과 같은 잎 노드가 있다.
B-트리 인덱스에서 검색이 성공적으로 이루어지면 최종적으로 데이터가 위치한 잎 노드에 도달하게 된다.
데이터는 잎 노드에 저장되며, MySQL의 B-트리 인덱스는 잎 노드에서 실제 데이터에 대한 포인터를 가진다.

B-트리의 중요한 특징 중 하나는 트리의 높이를 낮게 유지하는 것.
즉, 많은 데이터를 처리할 수 있는 노드들이 존재하더라도, 검색 과정에서 몇 번의 비교만으로도 원하는 데이터를 찾을 수 있다.
이렇게 하여 B-트리는 대량의 데이터베이스 레코드에 대해 효율적인 검색 성능을 제공.

B-트리는 각 노드 내에서 키가 정렬되어 있어 이진 탐색이 가능하다. 
이로 인해 검색이 빠르게 이루어진다. 노드 내의 키는 정렬된 상태로 유지되며, 이는 인덱스 스캔 시에도 효율적.

좀 더 자세한 예를 들어 보도록 하자.

![image](https://github.com/user-attachments/assets/82ff24de-035c-4e7a-b9ae-71558c62fbd1)


이 이미지는 MySQL의 B-트리 인덱스에서 Secondary Key를 사용한 데이터 검색 과정을 보여준다.

이는 MySQL에서 보조 인덱스(Secondary Index)로 사용되는 구조로,
보조 인덱스는 주 인덱스가 아닌, 다른 열(Col2)을 기준으로 데이터를 빠르게 검색하기 위해 사용된다.
여기서 인덱스는 Col2의 값을 기준으로 5, 34, 89, 100, 170 등의 값을 가지며, 이 값들에 대해 데이터를 빠르게 검색할 수 있도록 트리 구조로 되어 있다.

트리는 상위에서부터 여러 레벨로 나누어져 있으며, 각 노드가 키 값을 기준으로 자식 노드로 분기한다.
예를 들어, 키 값이 5라면 첫 번째 자식 노드로 이동하고, 34라면 다음 노드로 이동하여 그에 따른 하위 데이터로 연결.

트리의 말단에는 Leaf 노드가 존재하며, 여기에는 각 키 값에 연결된 데이터 포인터가 저장되어 있다.
이미지에서 보이는 "0x6A", "0x90" 등의 값들이 포인터에 해당.
예를 들어, 키 값이 5일 경우 Leaf 노드의 값은 "0x6A"로 표시되어 있다.
이 포인터는 실제 테이블의 데이터 행을 가리킨다.

이미지 오른쪽 하단에 있는 테이블(Col1, Col2, Col3)은 실제 데이터베이스 테이블을 나타낸다.
이 테이블에서 각 데이터 행은 Col1, Col2, Col3 열로 나누어져 있으며, 데이터는 포인터에 의해 참조.
예를 들어, 키 값이 5인 경우 "0x6A" 포인터는 Col1의 값이 20인 행을 가리킨다.
이 행의 Col2 값은 5이고, Col3의 값은 "Jim". 이렇게 B-트리 인덱스는 Leaf 노드에 저장된 포인터를 통해 실제 데이터를 찾아낸다.

MySQL에서 보조 인덱스를 사용한 검색은 먼저 Secondary Key에서 해당하는 키 값을 찾는 것으로 시작.
트리를 따라 내려가면서 키 값을 비교한 후 적절한 자식 노드로 이동.
최종적으로 Leaf 노드에 도달하면, 해당 키 값에 연결된 데이터 포인터를 찾는다.
이 포인터는 실제 데이터 테이블의 행을 가리키며, 이를 통해 해당하는 데이터를 가져오게 된다.

예를 들어, 91을 찾는다고 가정하자.

먼저 Secondary Key 구조의 루트 노드에서 91을 찾기 시작한다.
루트 노드에는 범위 값들이 존재하며, 현재 범위는 5, 100, 170과 같은 값이 있다.
91은 5보다 크고 100보다 작은 값이므로, 5~100 사이에 해당하는 하위 노드로 이동.

이제 두 번째 레벨에서 5, 34, 89 등의 값을 가진 노드를 만나게 된다. 91은 89보다 큰 값이므로, 89의 자식 노드로 이동.
자식 노드로 이동하면 Leaf 노드에서 89와 91이라는 값을 볼 수 있다.
여기서 91을 찾았으며, 이 91과 연결된 값은 0xF3이라는 데이터 포인터.

이제 91에 연결된 포인터 0xF3을 사용하여 실제 데이터 테이블의 행에 접근할 수 있다.
이 포인터는 MySQL에서 데이터베이스 테이블의 특정 행을 가리킨다.
이미지 하단의 테이블을 보면, 포인터 0xF3은 Col1이 30이고, Col2가 91인 행을 가리킨다.
Col3의 값은 Eric. 따라서 91에 해당하는 데이터는 Col1 = 30, Col2 = 91, Col3 = "Eric"인 행.

#### 인덱스가 효율적인 이유와 대수확장성
인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문.
대수확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미.
기본적으로 인덱스의 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배 증가.

![image](https://github.com/user-attachments/assets/5afa3c87-e4aa-43ab-b808-91e064b02fa0)

앞의 표처럼 트리 깊이는 10개짜리로, 100만개의 레코드를 검색할 수 있다는 의미.
참고로 실제 인덱스는 이것보다 훨씬 효율적이며 그렇기 때문에 인덱스가 효울적이라 볼 수 있다.

### 인덱스 만드는 방법

인덱스를 만드는 방법은 데이터베이스마다 다르며 MySQL과 MongoDB를 기준으로 설명한다.

#### MySQL
MySQL 의 경우 클러스터형 인덱스와 세컨더리 인덱스가 있으며
클러스터형 인덱스는 테이블당 하나를 설정할 수 있다.
primary key 옵션으로 기본키를 만들면 클러스터형 인덱스를 생성할 수 있고
기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.

create index... 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있다.
하나의 인덱스만 생성할 거라면 클러스터형 인덱스를 만드는 것보다 성능이 좋다.

세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스다.
예를 들어 age 라는 하나의 필드만으로 쿼리를 보낸다면 클러스터형 인덱스만 필요할 것.
하지만 age, name, email 등 다양한 필드를 기반으로 쿼리를 보낼 때는 세컨더리 인덱스를 사용해야 한다.

#### MongoDB
MongoDB의 경우 도큐먼트를 만들면 자동으로 ObjectID 가 형성되며 해당 키가 기본키로 설정된다.
그리고 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스로 설정할 수 있다.

### 인덱스 최적화 기법

인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같기 때문에 특정 데이터베이스를 기준으로 설명해도 뭅방하다.
이 책에서는 MongoDB를 기반으로 인덱스 최적화 기법을 설명하며, 이를 기반으로 다른 데이터베이스에 웬만큼 적용할 수 있다.

#### 1. 인덱스는 비용이다
먼저 인덱스는 두번 탐색하도록 강요한다. 인데스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문에 관련 읽기 비용이 들게 된다.
또한 컬렉션이 수정됐을 때 인덱스도 수정돼야 한다. 마치 책의 본문이 수정되었을 때 목차나 찾아보기도 수정해야 하는 것.
이때 B-트리의 높이를 균형있게 조절하는 비용도 들고 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 된다.

그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 건 답이 아니다.
또한 컬랙션에서 가져와야 하는 양이 많을 수록 인덱스를 사용하는 건 비효율적.

#### 2. 항상 테스팅하라
인덱스 최적화 기법은 서비스 특징에 따라 달라진다.
서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문.
그렇기 때문에 항상 테스팅 하는게 중요하다. explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 한다.
참고로 MySQL 에서는 다음과 같은 코드로 테스팅을 수행한다
```mysql
EXPLAIN 
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1
```

#### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데
이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.
같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다.

1. 어떠한 값과 같음을 비교하는 == 이나 equal 이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.
2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다.
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다.
4. 유니크한 값의 정도를 카디널리티라고 한다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다. 예를 들어 age와 email이 있다 해보자. email이 더 높을 것. 즉 email이라는 필드에 대한 인덱슬르 먼저 생성해야 한다.
